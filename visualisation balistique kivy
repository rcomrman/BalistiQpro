import matplotlib.pyplot as plt
import numpy as np
import pyttsx3

engine = pyttsx3.init()

def ask_question(question):
    engine.say(question)
    engine.runAndWait()
    return input(question)
print("BallistiQPro _ Simulation de Balistique\n\
      Ce logiciel est une propriété exclusive de BallistiQPro. Toute utilisation non autorisée est strictement interdite.En installant ou en utilisant ce logiciel, vous acceptez les termes et conditions de la licence d'utilisation. Pour plus d'informations, veuillez contacter le support technique.© 2024 BallistiQPro. Tous droits réservés.")

# Choix du fusil de sniper
snip = input("Bienvenue dans ce simulateur balistique. Choisissez le fusil de sniper à utiliser :\n1 : Barrett M82A1 (calibre .50 BMG)\n2 : Accuracy International Arctic Warfare (calibre .338 Lapua Magnum)\n3 : Remington 700 (calibre .308 Winchester)\n4 : Sako TRG-42 (calibre .300 Winchester Magnum)\n5 : Autre (entrez vos propres valeurs) ")

# Assignation des paramètres du fusil en fonction du choix
v0x, v0y, v0z, k, v_vent, theta_vent = 0, 0, 0, 0, 0, 0  # Initialize the variables

if snip == "1":
    v0 = 853
    m = 0.045
elif snip == "2":
    v0 = 880
    m = 0.016
elif snip == "3":
    v0 = 780
    m = 0.010
elif snip == "4":
    v0 = 900
    m = 0.010

# Entrée des angles d'élévation et d'azimut
theta_azimut = np.radians(float(input("Quel est l'angle de tir horizontal (en degrés) : ")))  # Angle d'azimut en radians

# Calcul des composantes de vitesse initiale
v0x = v0 * np.cos(theta_azimut)
v0y = 0  # Pas de composante verticale
v0z = v0 * np.sin(theta_azimut)

# Coefficient de traînée
k = 0.5

# Entrée de la vitesse et de la direction du vent
v_vent = float(input("Quelle est la vitesse du vent (en m/s) : ") or 0)  # Valeur par défaut de 0 si aucune entrée
theta_vent = np.radians(float(input("Quelle est la direction horizontale du vent (en degrés) : ") or 0))  # Valeur par défaut de 0 si aucune entrée

# Rest of your code remains unchanged
# Valeurs initiales
x0, y0, z0 = 0, 0, 0

# Coefficient de traînée
k = 0.5  # Initialize k before using it in trajectory equations

# Définir les fonctions x(t), y(t), z(t) avec les valeurs initiales ajoutées
def x(t):
    result = x0 + v0x * t - (m/k) * v_vent * np.cos(theta_vent) * t - 0.5 * k * t**2
    return result

def z(t):
    result = z0 + v0z * t - 0.5 * 9.8 * t**2 - 0.5 * k * t**2
    return result

def y(t):
    result = y0 + v0y * t - (m/k) * v_vent * np.sin(theta_vent) * t - 0.5 * k * t**2
    return result

# Plage de représentation graphique
ecar = float(ask_question("Quel est l'écart de la représentation graphique (30 conseillé) : "))

# Générer des valeurs de temps sur une plage
t_values = np.linspace(0, ecar, 1000)

# Calculer les coordonnées correspondantes
x_values = x(t_values)
y_values = y(t_values)
z_values = z(t_values)

# Tracer la courbe en 3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot(x_values, y_values, z_values, label='Trajectoire du projectile')
ax.set_xlabel('Axe X')
ax.set_ylabel('Axe Y')
ax.set_zlabel('Axe Z')
ax.legend()

# Ajouter les vecteurs de vitesse initiaux à la position initiale
ax.quiver(x0, y0, z0, v0x, v0y, v0z, color='red', label='Vitesse de départ')

# Afficher le graphique
print ("[INFO] Initialisation du module balistique...")
print("[WARNING] Calibration en cours...")
print("[SUCCESS] Simulation terminée avec succès.")

plt.show()
